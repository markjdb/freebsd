Pull in r221170 from upstream clang trunk (by Roman Divacky):

  Implement vaarg lowering for ppc32. Lowering of scalars and
  aggregates is supported. Complex numbers are not.

This adds va_args support for PowerPC (32 bit) to clang.

Introduced here: http://svnweb.freebsd.org/changeset/base/275759

Index: tools/clang/lib/CodeGen/TargetInfo.cpp
===================================================================
--- tools/clang/lib/CodeGen/TargetInfo.cpp
+++ tools/clang/lib/CodeGen/TargetInfo.cpp
@@ -2733,12 +2733,20 @@ llvm::Value *NaClX86_64ABIInfo::EmitVAArg(llvm::Va
 
 
 // PowerPC-32
-
 namespace {
-class PPC32TargetCodeGenInfo : public DefaultTargetCodeGenInfo {
+/// PPC32_SVR4_ABIInfo - The 32-bit PowerPC ELF (SVR4) ABI information.
+class PPC32_SVR4_ABIInfo : public DefaultABIInfo {
 public:
-  PPC32TargetCodeGenInfo(CodeGenTypes &CGT) : DefaultTargetCodeGenInfo(CGT) {}
+  PPC32_SVR4_ABIInfo(CodeGen::CodeGenTypes &CGT) : DefaultABIInfo(CGT) {}
 
+  llvm::Value *EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
+                         CodeGenFunction &CGF) const;
+};
+
+class PPC32TargetCodeGenInfo : public TargetCodeGenInfo {
+public:
+  PPC32TargetCodeGenInfo(CodeGenTypes &CGT) : TargetCodeGenInfo(new PPC32_SVR4_ABIInfo(CGT)) {}
+
   int getDwarfEHStackPointer(CodeGen::CodeGenModule &M) const {
     // This is recovered from gcc output.
     return 1; // r1 is the dedicated stack pointer
@@ -2750,6 +2758,96 @@ namespace {
 
 }
 
+llvm::Value *PPC32_SVR4_ABIInfo::EmitVAArg(llvm::Value *VAListAddr,
+                                           QualType Ty,
+                                           CodeGenFunction &CGF) const {
+  if (const ComplexType *CTy = Ty->getAs<ComplexType>()) {
+    // TODO: Implement this. For now ignore.
+    (void)CTy;
+    return NULL;
+  }
+
+  bool isI64 = Ty->isIntegerType() && getContext().getTypeSize(Ty) == 64;
+  bool isInt = Ty->isIntegerType() || Ty->isPointerType() || Ty->isAggregateType();
+  llvm::Type *CharPtr = CGF.Int8PtrTy;
+  llvm::Type *CharPtrPtr = CGF.Int8PtrPtrTy;
+
+  CGBuilderTy &Builder = CGF.Builder;
+  llvm::Value *GPRPtr = Builder.CreateBitCast(VAListAddr, CharPtr, "gprptr");
+  llvm::Value *GPRPtrAsInt = Builder.CreatePtrToInt(GPRPtr, CGF.Int32Ty);
+  llvm::Value *FPRPtrAsInt = Builder.CreateAdd(GPRPtrAsInt, Builder.getInt32(1));
+  llvm::Value *FPRPtr = Builder.CreateIntToPtr(FPRPtrAsInt, CharPtr);
+  llvm::Value *OverflowAreaPtrAsInt = Builder.CreateAdd(FPRPtrAsInt, Builder.getInt32(3));
+  llvm::Value *OverflowAreaPtr = Builder.CreateIntToPtr(OverflowAreaPtrAsInt, CharPtrPtr);
+  llvm::Value *RegsaveAreaPtrAsInt = Builder.CreateAdd(OverflowAreaPtrAsInt, Builder.getInt32(4));
+  llvm::Value *RegsaveAreaPtr = Builder.CreateIntToPtr(RegsaveAreaPtrAsInt, CharPtrPtr);
+  llvm::Value *GPR = Builder.CreateLoad(GPRPtr, false, "gpr");
+  // Align GPR when TY is i64.
+  if (isI64) {
+    llvm::Value *GPRAnd = Builder.CreateAnd(GPR, Builder.getInt8(1));
+    llvm::Value *CC64 = Builder.CreateICmpEQ(GPRAnd, Builder.getInt8(1));
+    llvm::Value *GPRPlusOne = Builder.CreateAdd(GPR, Builder.getInt8(1));
+    GPR = Builder.CreateSelect(CC64, GPRPlusOne, GPR);
+  }
+  llvm::Value *FPR = Builder.CreateLoad(FPRPtr, false, "fpr");
+  llvm::Value *OverflowArea = Builder.CreateLoad(OverflowAreaPtr, false, "overflow_area");
+  llvm::Value *OverflowAreaAsInt = Builder.CreatePtrToInt(OverflowArea, CGF.Int32Ty);
+  llvm::Value *RegsaveArea = Builder.CreateLoad(RegsaveAreaPtr, false, "regsave_area");
+  llvm::Value *RegsaveAreaAsInt = Builder.CreatePtrToInt(RegsaveArea, CGF.Int32Ty);
+
+  llvm::Value *CC = Builder.CreateICmpULT(isInt ? GPR : FPR,
+                                          Builder.getInt8(8), "cond");
+
+  llvm::Value *RegConstant = Builder.CreateMul(isInt ? GPR : FPR,
+                                               Builder.getInt8(isInt ? 4 : 8));
+
+  llvm::Value *OurReg = Builder.CreateAdd(RegsaveAreaAsInt, Builder.CreateSExt(RegConstant, CGF.Int32Ty));
+
+  if (Ty->isFloatingType())
+    OurReg = Builder.CreateAdd(OurReg, Builder.getInt32(32));
+
+  llvm::BasicBlock *UsingRegs = CGF.createBasicBlock("using_regs");
+  llvm::BasicBlock *UsingOverflow = CGF.createBasicBlock("using_overflow");
+  llvm::BasicBlock *Cont = CGF.createBasicBlock("cont");
+
+  Builder.CreateCondBr(CC, UsingRegs, UsingOverflow);
+
+  CGF.EmitBlock(UsingRegs);
+
+  llvm::Type *PTy = llvm::PointerType::getUnqual(CGF.ConvertType(Ty));
+  llvm::Value *Result1 = Builder.CreateIntToPtr(OurReg, PTy);
+  // Increase the GPR/FPR indexes.
+  if (isInt) {
+    GPR = Builder.CreateAdd(GPR, Builder.getInt8(isI64 ? 2 : 1));
+    Builder.CreateStore(GPR, GPRPtr);
+  } else {
+    FPR = Builder.CreateAdd(FPR, Builder.getInt8(1));
+    Builder.CreateStore(FPR, FPRPtr);
+  }
+  CGF.EmitBranch(Cont);
+
+  CGF.EmitBlock(UsingOverflow);
+
+  // Increase the overflow area.
+  llvm::Value *Result2 = Builder.CreateIntToPtr(OverflowAreaAsInt, PTy);
+  OverflowAreaAsInt = Builder.CreateAdd(OverflowAreaAsInt, Builder.getInt32(isInt ? 4 : 8));
+  Builder.CreateStore(Builder.CreateIntToPtr(OverflowAreaAsInt, CharPtr), OverflowAreaPtr);
+  CGF.EmitBranch(Cont);
+
+  CGF.EmitBlock(Cont);
+
+  llvm::PHINode *Result = CGF.Builder.CreatePHI(PTy, 2, "vaarg.addr");
+  Result->addIncoming(Result1, UsingRegs);
+  Result->addIncoming(Result2, UsingOverflow);
+
+  if (Ty->isAggregateType()) {
+    llvm::Value *AGGPtr = Builder.CreateBitCast(Result, CharPtrPtr, "aggrptr")  ;
+    return Builder.CreateLoad(AGGPtr, false, "aggr");
+  }
+
+  return Result;
+}
+
 bool
 PPC32TargetCodeGenInfo::initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,
                                                 llvm::Value *Address) const {
Index: tools/clang/test/CodeGen/ppc64-varargs-struct.c
===================================================================
--- tools/clang/test/CodeGen/ppc64-varargs-struct.c
+++ tools/clang/test/CodeGen/ppc64-varargs-struct.c
@@ -1,5 +1,6 @@
 // REQUIRES: ppc64-registered-target
 // RUN: %clang_cc1 -triple powerpc64-unknown-linux-gnu -emit-llvm -o - %s | FileCheck %s
+// RUN: %clang_cc1 -triple powerpc-unknown-linux-gnu -emit-llvm -o - %s | FileCheck %s --check-prefix=CHECK-PPC
 
 #include <stdarg.h>
 
@@ -17,6 +18,46 @@ void testva (int n, ...)
 // CHECK: bitcast %struct.x* %t to i8*
 // CHECK: bitcast %struct.x* %{{[0-9]+}} to i8*
 // CHECK: call void @llvm.memcpy
+// CHECK-PPC:  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag]* %ap, i32 0, i32 0
+// CHECK-PPC-NEXT:  %gprptr = bitcast %struct.__va_list_tag* %arraydecay to i8*
+// CHECK-PPC-NEXT:  %0 = ptrtoint i8* %gprptr to i32
+// CHECK-PPC-NEXT:  %1 = add i32 %0, 1
+// CHECK-PPC-NEXT:  %2 = inttoptr i32 %1 to i8*
+// CHECK-PPC-NEXT:  %3 = add i32 %1, 3
+// CHECK-PPC-NEXT:  %4 = inttoptr i32 %3 to i8**
+// CHECK-PPC-NEXT:  %5 = add i32 %3, 4
+// CHECK-PPC-NEXT:  %6 = inttoptr i32 %5 to i8**
+// CHECK-PPC-NEXT:  %gpr = load i8* %gprptr
+// CHECK-PPC-NEXT:  %fpr = load i8* %2
+// CHECK-PPC-NEXT:  %overflow_area = load i8** %4
+// CHECK-PPC-NEXT:  %7 = ptrtoint i8* %overflow_area to i32
+// CHECK-PPC-NEXT:  %regsave_area = load i8** %6
+// CHECK-PPC-NEXT:  %8 = ptrtoint i8* %regsave_area to i32
+// CHECK-PPC-NEXT:  %cond = icmp ult i8 %gpr, 8
+// CHECK-PPC-NEXT:  %9 = mul i8 %gpr, 4
+// CHECK-PPC-NEXT:  %10 = sext i8 %9 to i32
+// CHECK-PPC-NEXT:  %11 = add i32 %8, %10
+// CHECK-PPC-NEXT:  br i1 %cond, label %using_regs, label %using_overflow
+//
+// CHECK-PPC-LABEL:using_regs:                                       ; preds = %entry
+// CHECK-PPC-NEXT:  %12 = inttoptr i32 %11 to %struct.x*
+// CHECK-PPC-NEXT:  %13 = add i8 %gpr, 1
+// CHECK-PPC-NEXT:  store i8 %13, i8* %gprptr
+// CHECK-PPC-NEXT:  br label %cont
+//
+// CHECK-PPC-LABEL:using_overflow:                                   ; preds = %entry
+// CHECK-PPC-NEXT:  %14 = inttoptr i32 %7 to %struct.x*
+// CHECK-PPC-NEXT:  %15 = add i32 %7, 4
+// CHECK-PPC-NEXT:  %16 = inttoptr i32 %15 to i8*
+// CHECK-PPC-NEXT:  store i8* %16, i8** %4
+// CHECK-PPC-NEXT:  br label %cont
+//
+// CHECK-PPC-LABEL:cont:                                             ; preds = %using_overflow, %using_regs
+// CHECK-PPC-NEXT:  %vaarg.addr = phi %struct.x* [ %12, %using_regs ], [ %14, %using_overflow ]
+// CHECK-PPC-NEXT:  %aggrptr = bitcast %struct.x* %vaarg.addr to i8**
+// CHECK-PPC-NEXT:  %aggr = load i8** %aggrptr
+// CHECK-PPC-NEXT:  %17 = bitcast %struct.x* %t to i8*
+// CHECK-PPC-NEXT:  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %17, i8* %aggr, i32 16, i32 8, i1 false)
 
   int v = va_arg (ap, int);
 // CHECK: ptrtoint i8* %{{[a-z.0-9]*}} to i64
@@ -23,8 +64,48 @@ void testva (int n, ...)
 // CHECK: add i64 %{{[0-9]+}}, 4
 // CHECK: inttoptr i64 %{{[0-9]+}} to i8*
 // CHECK: bitcast i8* %{{[0-9]+}} to i32*
+// CHECK-PPC:  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag]* %ap, i32 0, i32 0
+// CHECK-PPC-NEXT:  %gprptr2 = bitcast %struct.__va_list_tag* %arraydecay1 to i8*
+// CHECK-PPC-NEXT:  %18 = ptrtoint i8* %gprptr2 to i32
+// CHECK-PPC-NEXT:  %19 = add i32 %18, 1
+// CHECK-PPC-NEXT:  %20 = inttoptr i32 %19 to i8*
+// CHECK-PPC-NEXT:  %21 = add i32 %19, 3
+// CHECK-PPC-NEXT:  %22 = inttoptr i32 %21 to i8**
+// CHECK-PPC-NEXT:  %23 = add i32 %21, 4
+// CHECK-PPC-NEXT:  %24 = inttoptr i32 %23 to i8**
+// CHECK-PPC-NEXT:  %gpr3 = load i8* %gprptr2
+// CHECK-PPC-NEXT:  %fpr4 = load i8* %20
+// CHECK-PPC-NEXT:  %overflow_area5 = load i8** %22
+// CHECK-PPC-NEXT:  %25 = ptrtoint i8* %overflow_area5 to i32
+// CHECK-PPC-NEXT:  %regsave_area6 = load i8** %24
+// CHECK-PPC-NEXT:  %26 = ptrtoint i8* %regsave_area6 to i32
+// CHECK-PPC-NEXT:  %cond7 = icmp ult i8 %gpr3, 8
+// CHECK-PPC-NEXT:  %27 = mul i8 %gpr3, 4
+// CHECK-PPC-NEXT:  %28 = sext i8 %27 to i32
+// CHECK-PPC-NEXT:  %29 = add i32 %26, %28
+// CHECK-PPC-NEXT:  br i1 %cond7, label %using_regs8, label %using_overflow9
+//
+// CHECK-PPC-LABEL:using_regs8:                                      ; preds = %cont
+// CHECK-PPC-NEXT:  %30 = inttoptr i32 %29 to i32*
+// CHECK-PPC-NEXT:  %31 = add i8 %gpr3, 1
+// CHECK-PPC-NEXT:  store i8 %31, i8* %gprptr2
+// CHECK-PPC-NEXT:  br label %cont10
+//
+// CHECK-PPC-LABEL:using_overflow9:                                  ; preds = %cont
+// CHECK-PPC-NEXT:  %32 = inttoptr i32 %25 to i32*
+// CHECK-PPC-NEXT:  %33 = add i32 %25, 4
+// CHECK-PPC-NEXT:  %34 = inttoptr i32 %33 to i8*
+// CHECK-PPC-NEXT:  store i8* %34, i8** %22
+// CHECK-PPC-NEXT:  br label %cont10
+//
+// CHECK-PPC-LABEL:cont10:                                           ; preds = %using_overflow9, %using_regs8
+// CHECK-PPC-NEXT:  %vaarg.addr11 = phi i32* [ %30, %using_regs8 ], [ %32, %using_overflow9 ]
+// CHECK-PPC-NEXT:  %35 = load i32* %vaarg.addr11
+// CHECK-PPC-NEXT:  store i32 %35, i32* %v, align 4
 
+#ifdef __powerpc64__
   __int128_t u = va_arg (ap, __int128_t);
+#endif
 // CHECK: bitcast i8* %{{[a-z.0-9]+}} to i128*
 // CHECK-NEXT: load i128* %{{[0-9]+}}
 }
